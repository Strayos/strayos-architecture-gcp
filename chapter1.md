# Technical Specification

## Introduction

The project is divided into 3 processes

* gcpfind.py - CLI that finds gcps in an image list.
* gcpfind\_server - Program \(written in go\) that spawns gcpfind.py processes to handle request. 
* gcpfind\_culster - Cluster of nodes running the gcpfind\_server. 

Let's describe how these pieces work from a bottom-up perspective.

#### gcpfind.py

A typical run of gcpfind.py looks like this:

**$** Indicates standard out  
**&gt;** Indicates standard out

```
$ welcome to GCP detection
$ starting GCP detection
$ STAGE: GCP detection
$ PROGRESS: 0
$ PROGRESS: 50
$ PROGRESS: 100
$ RESPONSE: { gcp: "gcp1", file:"DJI001.JPG", location:[400, 555] }
$ Please send feedback
> { gcp: "gcp1", file:"DJI001.jpg", location:[450, 555] }
$ Response: { gcp: "gcp3", file: "DJI003.JPG", location: [300, 330] }
$ Please send feedback
> { gcp: "gcp3", file:"DJI001.jpg", location:[330, 300] }
... repeat until feedback has been sent for every gcp file. 
$ STAGE: GCP File Generation
$ Response: { gcp: "/home/code/gcp_list.txt", feedback: {} }
$ EXIT: 0
```

There are several things of note.  
1. Any output printed that does not begin with a whitelisted prefix is ignored by the automation script gcpfind\_server, and is purely for user input.

The whitelisted prefixes are:

* **STAGE**: _&lt;name of the stage&gt; _: Stage represents where gcpfind is currently at

* **PROGRESS**: _&lt;number from 0..100 representing the progress at this stage&gt;_: Progress indicates the progress of the current stage

* **RESPONSE**: _&lt;json response&gt;_ : Response notifies gcpfind\_server that data should be read in.
* **WAITING**:_&lt;&gt;_ : Waiting notifies gcpfind\_server that data should be sent in
* **EXIT**: _&lt;return code: 0 = SUCCESS xxx= FAILURE&gt;_: Exit the program immediately

1. During the "GCP detection stage" RESPONSE: and PROGRESS: commands may be intermixed \(Progress: 0, Response: {}, Progress: 10, Response: {}\)
2. The WAIT: command does not stall the program. It just indicates that something may be written to STDIN. 

#### gcpfind\_server

gcpfind\_server is an API wrapper around gcpfind that allows gcpfind to be run as a parallel jobs, and accessed over the web.   
Before explaining the intricacies of gcpfind\_server, let's walk through the typical workflow.

![](/assets/Screenshot %2877%29.png)

1. The user uploads their images along with the initial gcp template as specified by the gcpfind. The urls of these resources are then sent to gcpfind\_server. gcpfind\_server and gcpfind.py both run on the same machine. 
2. gcpfind\_server creates a new **Job**, a running instance of gcpfind, as well as a session.json which consist of metadata required by gcpfind.py. The images and gcp template are downloaded to a temporary directory, gcpfind.py is then run passing the directory with the images and gcp template in as command line arguments. 
3. gcpfind.py performs a first pass through the images, locating the ones it thinks has gcps and sending those to gcpfind\_server.
4. gcpfind\_server notifies the FE that gcpfind has found a gcp either through websockets or the front end polling some API endpoint. 
5. User refines the position of the gcps sent by the server and also marks images that definitely have no gcps. 
6. The front end send the information generated by step 5. to the server. 
7. The sever passes that information to gcpfind which waits until all estimated gcps are confirmed. Note that steps 3-7 happen intermittently. gcpfind will send gcps as it goes, and also listen for user confirmed ones at the same time. 
8. When all gcps are confirmed, gcpfind generates a final gcp_list.txt in the format required by ODM, and also a feedback.json which is essentially a log of it's guesses and what the user confirmed. It then exits. 
9. gcpfind\_server stores the feedback.json and passes the gcp_lists.txt to the front end. 
10. The Front End then uploads the gcp_list.txt file to the images folder as specified by ODM, and then flags the project for processing.
 


